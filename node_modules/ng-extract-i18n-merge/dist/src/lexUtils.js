"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLexClosestIndex = exports.LexDist = void 0;
class LexDist {
    constructor(dist) {
        this.dist = dist;
    }
    isNegative() {
        var _a;
        return ((_a = this.dist.find(d => d !== 0)) !== null && _a !== void 0 ? _a : 0) < 0;
    }
    smallerThan(other) {
        var _a, _b, _c, _d, _e, _f;
        let firstSignThis = 0;
        let firstSignOther = 0;
        for (let i = 0; i < Math.max(this.dist.length, other.dist.length); i++) {
            if (firstSignThis === 0) {
                firstSignThis = Math.sign((_a = this.dist[i]) !== null && _a !== void 0 ? _a : 0);
            }
            if (firstSignOther === 0) {
                firstSignOther = Math.sign((_b = other.dist[i]) !== null && _b !== void 0 ? _b : 0);
            }
            const thisDistI = firstSignThis ? firstSignThis * ((_c = this.dist[i]) !== null && _c !== void 0 ? _c : 0) : ((_d = this.dist[i]) !== null && _d !== void 0 ? _d : 0);
            const otherDistI = firstSignOther ? firstSignOther * ((_e = other.dist[i]) !== null && _e !== void 0 ? _e : 0) : ((_f = other.dist[i]) !== null && _f !== void 0 ? _f : 0);
            if (thisDistI < otherDistI) {
                return true;
            }
            else if (thisDistI > otherDistI) {
                return false;
            }
        }
        return false;
    }
    /**
     * "b - a"
     */
    static fromDifference(a, b) {
        const dist = [];
        for (let i = 0; i < a.length || i < b.length; i++) {
            dist.push((b.charCodeAt(i) || 0) - (a.charCodeAt(i) || 0));
        }
        return new LexDist(dist);
    }
    normalize() {
        const dist = [...this.dist];
        while (dist.length > 0 && dist[dist.length - 1] === 0) {
            dist.pop();
        }
        return new LexDist(dist);
    }
}
exports.LexDist = LexDist;
const DIST_MAX = new LexDist([Number.MAX_SAFE_INTEGER]);
function findLexClosestIndex(id, units, mapping) {
    // defaults work with empty list:
    let index = 0;
    let minDistance = DIST_MAX;
    for (let i = 0; i < units.length; i++) {
        const idNormalized = id.toLowerCase();
        const distance = LexDist.fromDifference(idNormalized, mapping(units[i]).toLowerCase());
        if (distance.smallerThan(minDistance)) {
            minDistance = distance;
            index = i;
        }
    }
    return [index, !minDistance.isNegative()];
}
exports.findLexClosestIndex = findLexClosestIndex;
